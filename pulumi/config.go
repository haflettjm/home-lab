package main

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
)

// VmConfig defines the specification for a single Proxmox VM. Each field maps
// to the corresponding key in the Pulumi stack config under "vmDefinitions".
type VmConfig struct {
	Name        string `json:"name"`
	Vmid        int    `json:"vmid"`
	Cores       int    `json:"cores"`
	MemoryMB    int    `json:"memoryMB"`
	DiskGB      int    `json:"diskGB"`
	IP          string `json:"ip"`
	Role        string `json:"role"`        // "server" (control plane) or "agent" (worker)
	Description string `json:"description"` // Human-readable VM description
}

// InfraConfig holds all configuration values required to provision the cluster.
type InfraConfig struct {
	NodeName     string
	TemplateVmId int
	SSHPublicKey string
	Gateway      string
	DNSServer    string
	Bridge       string
	Datastore    string
	VMs          []VmConfig
}

// LoadInfraConfig reads all infrastructure settings from Pulumi stack config
// and returns a fully populated InfraConfig. It returns an error if any
// required value is missing or cannot be parsed.
func LoadInfraConfig(ctx *pulumi.Context) (*InfraConfig, error) {
	cfg := config.New(ctx, "")

	nodeName := cfg.Require("nodeName")
	templateVmId := cfg.RequireInt("templateVmId")
	sshPublicKey := cfg.Require("sshPublicKey")
	gateway := cfg.Require("gateway")
	dnsServer := cfg.Require("dnsServer")
	bridge := cfg.Require("bridge")
	datastore := cfg.Require("datastore")

	// Parse the VM definitions list from the stack config. Pulumi serialises
	// complex config values as JSON, so we unmarshal into our struct slice.
	var vms []VmConfig
	vmDefsJSON := cfg.Require("vmDefinitions")
	if err := json.Unmarshal([]byte(vmDefsJSON), &vms); err != nil {
		return nil, fmt.Errorf("failed to parse vmDefinitions config: %w", err)
	}

	if len(vms) == 0 {
		return nil, fmt.Errorf("vmDefinitions config must contain at least one VM")
	}

	// Basic validation.
	for i, vm := range vms {
		if vm.Name == "" {
			return nil, fmt.Errorf("vmDefinitions[%d]: name is required", i)
		}
		if vm.Vmid <= 0 {
			return nil, fmt.Errorf("vmDefinitions[%d] (%s): vmid must be positive", i, vm.Name)
		}
		if vm.Role != "server" && vm.Role != "agent" {
			return nil, fmt.Errorf("vmDefinitions[%d] (%s): role must be 'server' or 'agent', got %q", i, vm.Name, vm.Role)
		}
		if vm.IP == "" {
			return nil, fmt.Errorf("vmDefinitions[%d] (%s): ip is required", i, vm.Name)
		}
	}

	return &InfraConfig{
		NodeName:     nodeName,
		TemplateVmId: templateVmId,
		SSHPublicKey: sshPublicKey,
		Gateway:      gateway,
		DNSServer:    dnsServer,
		Bridge:       bridge,
		Datastore:    datastore,
		VMs:          vms,
	}, nil
}

// GenerateCloudInitUserData produces a cloud-init user-data YAML string for a
// given VM. The generated config:
//   - Sets the hostname to the VM name.
//   - Creates an "admin" user with passwordless sudo and the provided SSH key.
//   - Installs and enables qemu-guest-agent (required for Proxmox to detect
//     the VM's IP address and for graceful shutdown).
//   - Configures the static IP address on the primary ethernet interface via
//     a runcmd script using nmcli.
//   - Disables cloud-init network config on subsequent boots to prevent it
//     from overwriting the static assignment.
func GenerateCloudInitUserData(vm VmConfig, sshPublicKey, gateway, dnsServer string) string {
	var b strings.Builder

	b.WriteString("#cloud-config\n")
	b.WriteString("# Auto-generated by Pulumi -- do not edit manually.\n\n")

	// Hostname -----------------------------------------------------------
	b.WriteString(fmt.Sprintf("hostname: %s\n", vm.Name))
	b.WriteString("manage_etc_hosts: true\n")
	b.WriteString(fmt.Sprintf("fqdn: %s.home.lab\n\n", vm.Name))

	// Users --------------------------------------------------------------
	b.WriteString("users:\n")
	b.WriteString("  - default\n")
	b.WriteString("  - name: admin\n")
	b.WriteString("    groups: wheel\n")
	b.WriteString("    sudo: ALL=(ALL) NOPASSWD:ALL\n")
	b.WriteString("    shell: /bin/bash\n")
	b.WriteString("    lock_passwd: true\n")
	b.WriteString("    ssh_authorized_keys:\n")
	b.WriteString(fmt.Sprintf("      - %s\n\n", sshPublicKey))

	// Packages -----------------------------------------------------------
	b.WriteString("package_update: true\n")
	b.WriteString("package_upgrade: true\n")
	b.WriteString("packages:\n")
	b.WriteString("  - qemu-guest-agent\n")
	b.WriteString("  - curl\n")
	b.WriteString("  - wget\n")
	b.WriteString("  - nano\n")
	b.WriteString("  - bash-completion\n\n")

	// Run commands -------------------------------------------------------
	// Configure the static IP, enable guest agent, and write a marker so
	// cloud-init does not re-run network config on subsequent boots.
	b.WriteString("runcmd:\n")
	// Enable and start qemu-guest-agent.
	b.WriteString("  - systemctl enable qemu-guest-agent\n")
	b.WriteString("  - systemctl start qemu-guest-agent\n")
	// Configure static IP using nmcli (Rocky Linux 9 uses NetworkManager).
	b.WriteString(fmt.Sprintf("  - nmcli con mod \"System eth0\" ipv4.addresses %s/24\n", vm.IP))
	b.WriteString(fmt.Sprintf("  - nmcli con mod \"System eth0\" ipv4.gateway %s\n", gateway))
	b.WriteString(fmt.Sprintf("  - nmcli con mod \"System eth0\" ipv4.dns \"%s\"\n", dnsServer))
	b.WriteString("  - nmcli con mod \"System eth0\" ipv4.method manual\n")
	b.WriteString("  - nmcli con up \"System eth0\"\n")
	// Prevent cloud-init from managing network on next boot.
	b.WriteString("  - echo 'network: {config: disabled}' > /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg\n\n")

	// Write files (optional metadata) ------------------------------------
	b.WriteString("write_files:\n")
	b.WriteString("  - path: /etc/homelab/node-role\n")
	b.WriteString(fmt.Sprintf("    content: \"%s\"\n", vm.Role))
	b.WriteString("    owner: root:root\n")
	b.WriteString("    permissions: '0644'\n")

	return b.String()
}
